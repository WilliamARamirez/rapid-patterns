import { Config, Generator, Schema } from "./meta-models";
import {
  buildNameVariations,
  camelCase,
  lowercase,
  pascalCase,
  startCase,
} from "./name-variations";
import { getConstructorParameters, getStringsFromProps } from "./shared-dotnet-utility-methods";

const generate = (schema: Schema, { name }: Config) => {
    const { ref, refs, model, models, singleParams } =
    buildNameVariations(schema);
    const { props } = schema;

  const propObjSchemas =   props.filter((p) => p.type === 'objectList').map((p) => {
    return buildNameVariations(p.value);
    });

    const constructorLists = propObjSchemas.map((p) => {
        return `List&lt;${p.model}DTO&gt; ${p.ref} = null`
    });

    const listAssignments = propObjSchemas.map((p) => {
        return `\t${p.ref} = ${p.ref} ?? new List&lt;${p.model}DTO&gt;()\n`
    }).join(";");

    const listAccessors = propObjSchemas.map((p) => {
       return `\tpublic List&lt;${p.model}DTO&gt; ${p.models} { get; set; }\n`
    }).join(";");

    const constructorParametersString= getConstructorParameters(props);
    const constructorParametersArr = constructorParametersString.split(",");
    const constructorArgs =  [`int id`,...constructorParametersArr,...constructorLists].join(", "); 

    const topLevelStrings = getStringsFromProps(props);

    const baseClassArgAssignment = topLevelStrings.map((s) => {
       return `\t${startCase(s.value)} = ${camelCase(s.value)};\n`
    }).join("");

    const baseClassArgAccessors = topLevelStrings.map((s) => {
         return `\tpublic string ${startCase(s.value)} { get; set; }\n`
    }).join("");

  const template = `
namespace ${name}.Web.ApiModels;

// ApiModel DTOs are used by ApiController classes and are typically kept in a side-by-side folder
public class ${model}DTO : Create${model}DTO
{
  public ${model}DTO(${constructorArgs}) : base(name, primaryContact)
  {
\tId = id;
${listAssignments}
  }
\tpublic int Id { get; set; }
  ${listAccessors}
}

// Creation DTOs should not include an ID if the ID will be generated by the back end
public abstract class Create${model}DTO
{
  protected Create${model}DTO(${constructorParametersString})
  {
    ${baseClassArgAssignment}
  }
${baseClassArgAccessors}

}`;

  return {
    template,
    title: `${model} Entity`,
    fileName: `libs/core-data/src/lib/services/${refs}/${refs}.service.ts`,
  };
};

export const DotnetDtoGenerator: Generator = {
  generate,
};
