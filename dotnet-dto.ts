import { Config, Generator, Schema } from "./meta-models";
import {
  buildNameVariations,
  camelCase,
  lowercase,
  pascalCase,
  startCase,
} from "./name-variations";
import {
  getConstructorParameters,
  getStringsFromProps,
} from "./shared-dotnet-utility-methods";

const generate = (schema: Schema, { name }: Config) => {
  const { ref, refs, model, models, singleParams } =
    buildNameVariations(schema);
  const { props } = schema;

  const propObjSchemas = props
    .filter((p) => p.type === "objectList")
    .map((p) => {
      return buildNameVariations(p.value);
    });

  const constructorLists = propObjSchemas.map((p) => {
    return `List&lt;${p.model}DTO&gt; ${p.refs} = null`;
  });

  const listAssignments = propObjSchemas
    .map((p) => {
      return `\t${p.models} = ${p.refs} ?? new List&lt;${p.model}DTO&gt;()\n`;
    })
    .join(";");

  const listAccessors = propObjSchemas
    .map((p) => {
      return `\tpublic List&lt;${p.model}DTO&gt; ${p.models} { get; set; }\n`;
    })
    .join(";");

  const constructorParametersString = getConstructorParameters(props);
  const constructorParametersArr = constructorParametersString.split(",");
  const constructorArgs = [
    `int id`,
    ...constructorParametersArr,
    ...constructorLists,
  ].join(", ");

  const topLevelStrings = getStringsFromProps(props);

  const baseClassArgAssignment = topLevelStrings
    .map((s) => {
      return `\t${startCase(s.value)} = ${camelCase(s.value)};\n`;
    })
    .join("");

  const baseClassArgAccessors = topLevelStrings
    .map((s) => {
      return `\tpublic string ${startCase(s.value)} { get; set; }\n`;
    })
    .join("");

  const template = `
namespace ${name}.Web.ApiModels;

// ApiModel DTOs are used by ApiController classes and are typically kept in a side-by-side folder
public class ${model}DTO : Create${model}DTO
{
\tpublic ${model}DTO(${constructorArgs}) : base(name, primaryContact)
\t{
\tId = id;
${listAssignments}
\t}
\tpublic int Id { get; set; }
  ${listAccessors}
}

// Creation DTOs should not include an ID if the ID will be generated by the back end
public abstract class Create${model}DTO
{
\tprotected Create${model}DTO(${constructorParametersString})
\t{
    ${baseClassArgAssignment}
\t}
${baseClassArgAccessors}

}`;

  return {
    template,
    title: `${model} Entity`,
    fileName: `libs/core-data/src/lib/services/${refs}/${refs}.service.ts`,
  };
};

export const DotnetDtoGenerator: Generator = {
  generate,
};
