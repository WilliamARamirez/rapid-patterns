import { Config, Generator, Schema } from "./meta-models";
import {
  buildNameVariations,
  camelCase,
  lowercase,
  pascalCase,
  startCase,
} from "./name-variations";
import {
  getConstructorParameters,
  getforeignObjSchemas,
  getValueTypeMembers,
} from "./shared-dotnet-utility-methods";

const generate = (schema: Schema, { name }: Config) => {
  const { ref, refs, model, models, singleParams } =
    buildNameVariations(schema);
  const { props } = schema;

  const foreignObjSchemas = getforeignObjSchemas(props);

  const ctorsForForeignObjects = foreignObjSchemas.map((s) => {
    return `List&lt;${s.model}DTO&gt; ${s.refs} = null`;
  });

  const foreignObjAssignments = foreignObjSchemas
    .map((p) => {
      return `\t${p.models} = ${p.refs} ?? new List&lt;${p.model}DTO&gt;()\n`;
    })
    .join(";");

  const foreignObjAccessors = foreignObjSchemas
    .map((p) => {
      return `\tpublic List&lt;${p.model}DTO&gt; ${p.models} { get; set; }\n`;
    })
    .join(";");

  const ctorArgsString = getConstructorParameters(props);
  const ctorArgsArr = ctorArgsString.split(",");
  const constructorArgs = [
    `int id`,
    ...ctorArgsArr,
    ...ctorsForForeignObjects,
  ].join(", ");

  const valueTypeMembers = getValueTypeMembers(props);

  const baseClassArgAssignment = valueTypeMembers
    .map((s) => {
      return `\t${startCase(s.value)} = ${camelCase(s.value)};\n`;
    })
    .join("");

  const baseClassArgAccessors = valueTypeMembers
    .map((s) => {
      return `\tpublic string ${startCase(s.value)} { get; set; }\n`;
    })
    .join("");

  const template = `
namespace ${name}.Web.ApiModels;

// ApiModel DTOs are used by ApiController classes and are typically kept in a side-by-side folder
public class ${model}DTO : Create${model}DTO
{
\tpublic ${model}DTO(${constructorArgs}) : base(name, primaryContact)
\t{
\tId = id;
${foreignObjAssignments}
\t}
\tpublic int Id { get; set; }
  ${foreignObjAccessors}
}

// Creation DTOs should not include an ID if the ID will be generated by the back end
public abstract class Create${model}DTO
{
\tprotected Create${model}DTO(${ctorArgsString})
\t{
    ${baseClassArgAssignment}
\t}
${baseClassArgAccessors}

}`;

  return {
    template,
    title: `${model} Entity`,
    fileName: `libs/core-data/src/lib/services/${refs}/${refs}.service.ts`,
  };
};

export const DotnetDtoGenerator: Generator = {
  generate,
};
